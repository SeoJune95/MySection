//// 여러가지 숫자 표기법.
//// e 뒤에 숫자가 0의 갯수를 의미
//let millionaire = 1000000000;
//let myNumber = 1e9;
//
//console.log(millionaire);
//console.log(myNumber);
//console.log(millionaire==myNumber);
//
//console.log(25e5 === 2500000);
//console.log(5.3e3 === 5300);
//console.log(-6.1e8 === -610000000);
//
//console.log(16e-5 === 0.00016);
//console.log(3.5e-3 === 0.0035);
//console.log(-9.1e-5 === -0.000091);

////16진수 표기법
//let hex1 = 0xff; // 255임
//let hex2 = 0xFF; // 255임
//console.log(hex1);
//console.log(hex2);
//
////8진수 표기법
//let octal = 0o377;
//console.log(octal); // 255임
//
////2진수 표기법
//let binary = 0b11111111; // 255임
//console.log(binary);


////자바에선 숫자도 객체.
////toFixed 는 파라미터로 값을 넣어주면 소수점 자리수 파라미터의 값 자리까지 표현. 반올림 함.
////파리미터로 전달하는값이 숫자의 자릿수를 초과하는경우 모두 0 으로 대체.
////이런건 모두 문자열로 표기됨. 사칙연산을 하려면 숫자형으로 변환(Number(~~~))
//let myNumber=0.3591;
//console.log(typeof Number(myNumber.toFixed(3)));
//console.log(typeof +myNumber.toFixed(8)); // Number 형변환 메소드를 사용할때 + 로 간단하게 사용 가능.
////진법 변환
//console.log(myNumber.toString(2)); // 2진법으로 변환
//console.log(myNumber.toString(8)); // 8진법으로 변환
//console.log(myNumber.toString(16)); // 16진법으로 변환  이는 모두 string형임.
////숫자형에 바로 메소드 사용
////console.log(255.toString(2)); // 이는 오류 why? 정수에 . 을 찍으면 소수점이라고 판단해서.
//console.log(255..toString(2)); // 그래서 점을 2개 찍어줌.
//console.log((255).toString(2)); // 숫자를 ()로 감싸고 뒤에 .toString 사용 해도 됌.


////math 객체가 있음.
//console.log(Math.abs(-10));  // Math.abs() 는 절대값
//console.log(Math.abs(10));
//
//console.log(Math.max(2,-2,4,5,8)); // Math.max(x,z,y)는 최대값을 리턴
//
//console.log(Math.min(2,-2,4,5,8)); // Math.min(x,z,y)는 최솟값을 리턴
//
//console.log(Math.pow(2,3)); // Math.pow(x,y)는 제곱를 나타냄.ex) Math.pow(2,3) 은 2의 3승
//console.log(Math.pow(5,2));
//
//console.log(Math.sqrt(25)); // Math.sqrt(x)는 x의 제곱근을 나타냄.
//console.log(Math.sqrt(64)); // Math.sqrt(x)는 제곱근을 나타냄.
//
//console.log(Math.round(2.3));
//console.log(Math.round(2.4));
//console.log(Math.round(2.49)); // Math.round(x)는 x에 반올림한 값을 리턴. 5부터 올림. .49는 버림.
//console.log(Math.round(2.5));
//console.log(Math.round(2.6));
//
//console.log(Math.floor(2.4));  // Math.floor(x.y)는 버림
//console.log(Math.floor(2.69));
//console.log(Math.floor(2.48));
//console.log('==================');
//console.log(Math.ceil(2.44));  // Math.ceil(x.y)는 올림
//console.log(Math.ceil(2.45));
//console.log(Math.ceil(2.9));
//
//console.log(Math.random()); // Math.random() 은 0 이상 1 이하의 값이 랜덤으로 리턴
//console.log(Math.random());
//console.log(Math.random());
//console.log(Math.random());
//
////이외에도 Math 메서드에는 많은 기능이 있음. 한번씩 찾아보시길~



//let sum=0.1+0.2;
//console.log(sum); // 결과값 : 0.30000000000000004 으로 나옴. 이는 자바스크립트만의 문제가 아님. 조금의 오차가 존재함.
//console.log(sum.toFixed(1)); // toFixed 사용해서 반올림해버림.toFixed는 문자형 숫자로 사용하려면 형변환 진행.
//console.log(+sum.toFixed(1)); // 또는
//console.log(Number(sum.toFixed(1))); // 로 형변환.
//console.log(Math.round(sum*10)/10); // 로 사용가능.


////여러가지 할당 방법..? 객체, 배열, 문자, 등등..
//let x = 3;
//let y = x;
//console.log(x); //3
//console.log(y); //3
//y=5;
//console.log(x); //3
//console.log(y); //5

//let x = {name:'Hello'};    //프로퍼티 1개의 객체를 변수x에 할당 (어딘가에서 name:'Hello' 가 만들어지고 그 주소값을 x에 저장함.)
//let y = x;                  // y에 x가 가지고 있는 객체의 주소를 할당받음. 결국 서로 같은 객체의 주소를 가지고 있음.
//console.log(x); //{name: 'Hello'}
//console.log(y); //{name: 'Hello'}
//y.birth=2022;               // Y에 새로운 프로퍼티를 추가
//console.log(x); //{name: 'Hello', birth: 2022}
//console.log(y); //{name: 'Hello', birth: 2022}  // 주소값이 저장 되었으니 y.birth 로 추가할때 객체로 접근하는 주소에 접근해서 추가함.
////객체는 참조형 자료형이다. why? 주소값에 접근해서 값을 가져오기 때문.
////한개 더 예를 들어서
//let x = [1,2,3];
//let y = x;
//console.log(x);
//console.log(y);
//y[2] = 4;
//console.log(x);
//console.log(y);
////배열도 똑같이 인덱스(주소) 를 배열이 가지고 있어서 3이 4로 변할수 있음.


//let x = 'Hello';
//let y = x;
//y = x + '!'; // y안에는 Hello! 가 들어가 있다.
//x = y.toLowerCase(); // y.toLowerCase()의 반환을 x 로 넣기 때문에 y 안에 Hello! 는 그대로임.
//console.log(y); //Hello!
//console.log(x); //hello!

//let x = ['Kim','Na','Park','Lee'];   // 배열의 인덱스 값이 저장 되는거임.
//let y = x;                          // y 에다가 x 배열의 주소값을 저장
//y.push('Lim');                      // y 배열에다가 push함. push는 배열의 제일 마지막에
//x[4] = 'Sung';                      // x 의 5번째 배열을 'Sung' 으로 변경.
//console.log(y); //['Kim', 'Na', 'Park', 'Lee', 'sung'] // y 와 x 의 배열의 인덱스 값이 같기에 5번째 Lim 을 Sung 으로 바꿈.



//let x = {
//    numbers : [1,2,3,4],
//    title : 'Hello'
//}; // 2개의 프로퍼티를 가진 객체 x 객체는 참조형이기 때문에 주소가 저장.
//let y = x.numbers;  // x의 numbers 프로퍼티값을 y 에 할당. numbers는 배열이기 때문에 주소값이 할당.
//let z = x.title;    // x의 title 프로퍼티를 변수 z에 할당. title은 기본형 값이기 때문에 값 Hello 가 그대로 복사.
//x.numbers.unshift(5); // x.numbers 배열의 제일 앞에 5를 추가
//x.title = 'Iu'; // x안의 title에 Iu 추가
//console.log(y); // (5) [5, 1, 2, 3, 4]
//console.log(z); // Hello z에는 처음 Hello일때의 x.title이 저장되어있음.
//console.log(x.title); // Iu
//배열은 주소값을 저장하기 때문에 number1 이나 number2 를 수정하면 둘다 추가됌.
//let number1 = [1,2,3];
//let number2 = number1;
//number2.push(4);
//console.log(number1);
//console.log(number2);

//그럼 참조형은 어떻게 한쪽만 추가하나?
//let number1 = [1,2,3];
//let number2 = number1.slice(); // slice() 를 사용하면 원래의 값이 그대로 떨어지기 때문에 복사한거 처럼 보인다.
//number2.push(4);
//console.log(number1); // [1, 2, 3]
//console.log(number2);  // [1, 2, 3, 4]
//
////객체는 어떻게 한쪽만 추가하나?
//let course1 = {
//    title:'자바스크립트 왕되기',
//    language:'JS',
//};
//let course2 = Object.assign({},course1);  // Object.assign({},객체이름) 을 해주면 된다.
//course2.title = '알고리즘 부시기';
//console.log(course1);
//console.log(course2);

//for in 문으로도 가능함.
//let course2 = {};
//for(let key in course1) {
//    course2[key] = course1[key];
//}
//course2.title = '알고리즘 부시기';
//console.log(course1);
//console.log(course2);

//let course2 = {};
//function copy() {
//    for(let i = 0; i = course2.length, i++;){
//        course2[i] = course1[i];
//    }
//}
//course2.title='알고리즘 부시기';
//console.log(course1);
//console.log(course2);

//function cloneObject(object){
//    let temp={};
//    for (let key in object) {
//        temp[key] = object[key];
//    }
//    return temp;
//}
//let course1 = {
//    title:'자바스크립트 왕되기',
//    language:'JS'
//};
//let course2 = cloneObject(course1);
//course2.title = '알고리즘 부시기';
//console.log(course1);
//console.log(course2);

////객체에 배열이 있다면?
//function cloneObject(object){
//    let temp={};
//    if(object === null || typeof object !== 'object'){
//        return object;
//    }
//    for (let key in object) {
//        temp[key] = object[key];
//    }
//    return temp;
//}
//let course1 = {
//    title:'자바스크립트 왕되기',
//    language:'JS',
//    prerequisite:[],
//};
//let course2 = cloneObject(course1);
//course2.title = '알고리즘 부시기';
//course2.prerequisite.push('자바스크립트 왕되기');
//console.log(course1);
//console.log(course2);

//// 변수는 const를 사용하는걸 권장한다. let 과 const 차이
//// let 은 재할당 가능 const 는 재할당 불가. //상수는 기본적으로 대문자로 시작하고 여러단어 조합엔 _ 를 추가. MY_NAME << 상수 선언
//let x = 1;
//console.log(x);
//x = 2;
//console.log(x);
//// 이처럼 let 으로 선언한 x 의 값을 재할당 가능함.
//const y = 3;
//y = 4;
////const는 에러가남. 상수이기 때문에 재할당 불가능.

//const x = {name:'서준혁',
//    age:14,
//    address:'울산'
//};
//x.name='성중형';
//console.log(x);
// 객체는 const로 선언해도 객체는 값을 저장해있는게 아니라 index(주소값)값을 저장해놓기 떄문에 바뀜.




























